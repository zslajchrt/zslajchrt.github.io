---
layout: post
title: Developing Protean Application With Morpheus - Part 9
comments: true
permalink: developing-protean-applications-part9
---

###Case Study Conclusion

The two case studies analyzed in this chapter showed that modeling multidimensional
objects may be surprisingly difficult in Java, Scala and Groovy as three representatives of
current popular languages. Java as a non-trait language has proven to be the least
suitable language for the multidimensional modeling. Because of the lack of traits,
one must resort to compositions and delegations, which leads to obscuring both type
and behavior during consecutive mappings between domains. In Scala each form
of a given object must be declared as a class. Since the number of forms grows
exponentially with the number of dimensions, the number of class declarations
quickly becomes unsustainable. Groovy can cope with this problem by means of
the dynamic traits applied on objects at runtime, however in contrast to Scala,
its weak type system is not able to guarantee the consistency of trait compositions
made in a step-by-step way (i.e. imperatively).

In the course of the case study analysis a new concept of the class builder
has been developed and treated as an additional platform evaluated in each scenario.
The class builder is conceived as an extension of Scala and its purpose is
to generate a class for any possible trait composition given by a model, which
is defined by means of a special type expression. The compiler extension
should be able to check the consistency of the model by decomposing the model
type and examining the dependencies of all individual traits specified in the traits'
self-type.

When instantiating a new object the class builder selects the right trait composition,
called alternative, according to the recommendation of the class builder strategy.
Since the strategy does not determine the trait compositions directly and only hints,
which prefabricated alternatives match some external conditions, it is guaranteed
that the builder always generates a class made up of mutually consistent set of traits
corresponding to one alternative given by the statically checked model.

In case the class builder is instantiated with an incomplete model (i.e. it has
some missing dependencies), a special reference object must be passed to the class
builder's constructor. Through this reference the compiler extension can trace
the model type associated with the reference and verify whether that model
delivers all missing dependencies.

The combination of an incomplete model with the special reference may be considered
an equivalent to the mapping between two domains. Such a mapping has all the appealing
properties formulated in the analysis for domain mappings: it uses neither delegation
nor composition (no type schizophrenia); the source trait proxies form the
resulting target composition in line with the target trait proxies (the source
proxies do not sink).

The following paragraphs are focusing on anchoring some basic terminology and on
conceptual requirements for the class builder.

####Tentative Terminology And Conceptual Requirements

The terminology defined here should be seen as conceptual, which is going to
be sharpened in the course of this work.

#####Morph Fragment

A **morph fragment** is a building block in multidimensional compositions of objects.
It corresponds semantically to the concept of trait as defined in Scala or Groovy
and as it has been used throughout the case study.

A morph fragment represents a typological, behavioral and structural element of
multiform objects.

#####Morph Type

A **morph type** is a type produced by a special type expression. By the type expression
the developer declares all possible *alternatives*, i.e. compositions of fragments
(forms).

The type expression is equivalent to a *non-recursive context-free grammar*
generating a language, where no term (i.e. fragment) occurs more than once in any
sequence in the language.

A **complete morph type** generates complete alternatives only.

#####Morph Alternative

A **morph alternative** or alternative corresponds to one of the fragment compositions
generated by a morph type.

A **complete morph alternative**Â is an alternative, in which all dependencies
of all fragments are satisfied. A fragment's dependency is satisfied in an alternative,
if the alternative contains another fragment compatible with the dependency.

The **alternative's type** is the type composed of all fragment types in the alternative.

#####Lowest Upper Bound (LUB) of Morph Type

A **lowest upper bound** is the most specific type yet compatible with the types of all alternatives.

#####Morph Model

A **complete morph model** defines all possible alternatives (forms) of objects instantiated
from it. The morph model is built by the compiler from the morph type. The compiler
analyses the morph type, builds the model from it and performs various checks to guarantee
that all alternatives are consistent.

An **incomplete morph model** is a morph model built from an incomplete morph
type. Such a model can be also seen as abstract, because no object may be
instantiated from it. To do so, the incomplete model must be merged with other
morph model, possibly also incomplete, to produce a complete morph model.
This merging corresponds to a domain mapping.

#####Object Metamorphism

**Object metamorphism** is a capability of an object to assume one or more forms
defined by the object's morph model. Naturally, the object assumes only one
form at a given moment.

#####Morph

A **morph** is an instance of a morph alternative. It is in fact a proxy object
implementing all fragments in the alternative by delegation. A morph is created
by the *morph assembler* (see below).

A **mutable morph** is a morph, which may be transparently *remorphed* to another
alternative. It is important in situation when the client of the morph should
be shielded from changes in the morph's composition.

All morphs created from the same object implement the lowest upper bound type (LUB)
of the model. Thus, any client communicating through the LUB should not be affected.

#####Morph Reference

A morph assembler (see below) may return the morph wrapped in a **morph reference**.
This reference keeps a link to the morph model, from which the morph is created.

Thanks to this link, an incomplete morph model may be transformed to a complete
one by composing it with the morph model carried by a morph reference. The morphs
produced from this joined type implement the fragments from both models.

#####Morpher

**Morpher** is an umbrella term for an implementation of object metamorphism.
It consists of two subunits: *morph assembler* and *morph mapper*.

#####Morph Assembler

The **morph assembler** is a component responsible for the morph model management
and morph instantiation. Its compile-time part parses and validates morph models,
while its runtime part corresponds to the class builder from the case study,
which is responsible for generating classes for all alternatives in the morph
model associated with the assembler. It uses the generated classes to create
morphs.

#####Morph Mapper

The **morph mapper** is a compile-time component composing one morph model with
another. It performs a series of checks to guarantee that the two model produce
a complete morph model.

#####Morph Strategy

A **morph strategy** is an object assisting the morpher during the instantiation
of a morph in the selection of the right alternative. The morph strategy
is receiving all possible alternatives one by one and is replying by
a recommendation statement. It follows that the morpher can never instantiate
an invalid composition of fragments. The only risk is that the strategy is
not properly configured or implemented and may thus recommend improper alternatives.

####Code Samples

#####Morph Fragments

A fragment with no dependency:

```scala
trait Rectangle {
  var width: Float = _
  var height: Float = _

  def calculateArea: Float = width * height
}
```

A fragment with dependencies:

```scala
trait ScannedBanknote {
  this: Banknote with Rectangle with Paper =>

  //...
}
```


#####Morph Type Expression

A complete type expression:

```
Thing with (Metal or Paper) with (Rectangle or Cylinder)
```

This expression may be rewritten to the disjunctive normal form:

```
(Thing with Metal with Rectangle) or
(Thing with Metal with Cylinder) or
(Thing with Paper with Rectangle) or
(Thing with Paper with Cylinder)
```

An incomplete type expression:

```
(ScannedBanknote with Banknote) or (ScannedCoin with Coin)
```

#####Bulding a morph with the post-initializer

```scala
  val itemBuilder = new ClassBuilder[Thing with (Metal or Paper) with (Rectangle or Cylinder)]({
    case rect: Rectangle =>
      rect.width = event.get("rectangle").get("width")
      rect.height = event.get("rectangle").get("height")
    case cyl: Cylinder =>
      cyl.height = event.get("cylinder").get("height")
      cyl.radius = event.get("cylinder").get("radius")
  })
  val item = Thing with Material with Shape = classBuilder.newInstance
```

#####Custom Morph Strategy

```scala
val userBuilderStrategy = new ClassBuilderStrategy {
  def isRecommended(alt: Alternative): Boolean = if (isOfficeHours) {
    alt.containsTrait[Employee]
  } else {
    userData.get("premium") match {
      case true => alt.containsTrait[RegisteredUser] && alt.containsTrait[PremiumUser]
      case _ => alt.containsTrait[RegisteredUser] && !alt.containsTrait[PremiumUser]
    }
  }
}

val userRef = userBuilder.newInstanceRef(userBuilderStrategy)
```

#####Composing Incomplete Model to Produce Complete One

```scala
type ItemModel = Thing with (Metal or Paper) with (Rectangle or Cylinder)
type ScannedCurrencyModelWithLoaders = (ScannedBanknote with BanknoteLoader) or (ScannedCoin with CoinLoader)

def makeCurrency(itemRef: Ref[ItemModel]): Ref[ScannerCurrencyModel] = {
  val curBuilder = new ClassBuilder[ScannedCurrencyModelWithLoaders](itemRef)
  loaderBuilder.newInstanceRef
}
```

#####Mutable Morphs

Creating a mutable morph:

```scala
val mailService: UserMail with MutableInstance[MailServiceModel] = mailServiceRef.mutableInstance
```

Evaluating the mutable morph's delegate reference:

```scala
mailService.delegate match {
  case Employee => // handle an employee
  case RegisteredUser with PremiumUser => // handle a premium registered user
  case RegisteredUser => // handle a registered non-premium user
}
```
